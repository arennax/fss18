# Homework Week4


## Todo

1. The usual instructions. Directory = `w4`.


## Background : `Dom`

Zitler's indictor-based domination score is a handy aggregation
function for multipe numeric goals. As we define it, it converts
number numeric goals (that we want to minimize or maximize)
into one valie 0 to 1 where ``1'' is comparatively better (than most goals)
on most
goals
while ``0'' is comparatively worse.

For example, here are some rows
of [auto.csv](https://raw.githubusercontent.com/timm/lean/master/data/auto.csv)

       cylinders,$displacement,$horsepower,<weight,>acceltn,$model,origin,>mpg
       8	304	193	4732	18.5	70	1	10
       8	360	215	4615	14	70	1	10
       8	307	200	4376	15	70	1	10
       8	318	210	4382	13.5	70	1	10
       8	429	208	4633	11	72	1	10
       8	400	150	4997	14	73	1	10
       8	350	180	3664	11	73	1	10
       8	383	180	4955	11.5	71	1	10
       ....

From the first row,  we see we want to minumze weight and maximize acceleration and mpg. 

Suppose we  add the `dom`
score to each row, sort  by that score, then  print the frist and last few lines,
This results in:

        cylinders,$displacement,$horsepower,<weight,>acceltn,$model,origin,>mpg,>dom
        8	350	180	4499	12.5	73	1	10	0
        8	400	175	5140	12	71	1	10	0
        8	455	225	4951	11	73	1	10	0
        8	383	180	4955	11.5	71	1	10	0.01
        8	400	175	4464	11.5	71	1	10	0.01
        8	429	198	4952	11.5	73	1	10	0.01
        ...     ...     ...     ...     ....    ...     ...     ...     ...
        4	90	48	2085	21.7	80	2	40	0.99
        4	90	48	2335	23.7	80	2	40	0.99
        4	85	70	2070	18.6	78	3	40	1.0
        4	89	60	1968	18.8	80	3	40	1.0
        4	97	52	2130	24.6	82	2	40	1.0

Obsreve that the _highest_ dom scores are assocaited wiht rows with least weight, most acceleration
and most mpg (and the _lowest_ dom scores are associated with the reverse).

To compute the dom score for a row, we has how many other rows does this _dominate_.
According to Zilter, X dominates Y if when we move from X to Y we loss less than when we comvov Y to X.

An incremental sampling methods runs over the data once, updating its internal measures as it goes.

A _reservoir sampler_ keeps a fixed number of items (and if it sees more, it deletes existing ones at random).

A _Gaussian sampler_ incrementally updated means and standard deviations.

A _entropy sampler_ incrementally updates the ratios at which various symbols are used.

The first two are for numbers and the last is for symbols.

FYI: my implementation of the second uses the first as a sub-routine.

The directory
[https://github.com/timm/lean/blob/master/tests/](https://github.com/timm/lean/blob/master/tests/)
contains unit tests for  in `sample.lua`, `num.lua`, `sym.lua`.
which are
(respectively)
a _reservoir sampler_ ;
a _Gaussian sampler_; and a
_entropy sampler_.


Port the unit tests to my test engine method `O.k`. Use those tests to check your Python versions of
`sample.lua`, `num.lua`, `sym.lua` in
[https://github.com/timm/lean/blob/master/src/](https://github.com/timm/lean/blob/master/src/).
the directory 
